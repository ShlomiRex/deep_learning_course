def prod(val):
    res = 1
    for ele in val:
        res *= ele
    return res


from_size = 2
to_size = 5
max_value = 3

a_sizes = []
b_sizes = []
for i in range(from_size, to_size):
    a_size = [1] * i
    for j in range(pow(max_value, len(a_size))):
        a_sizes.append(tuple(a_size))
        b_sizes.append(tuple(a_size))
        a_size[0] += 1
        if a_size[0] == max_value + 1:
            for k in range(len(a_size)):
                if a_size[k] == max_value + 1:
                    a_size[k] = 1
                else:
                    a_size[k] += 1
                    k = len(a_size)

test = torch.zeros(1)
error_counter = 0
for a_size in a_sizes:
    A = torch.arange(prod(a_size)).reshape(a_size)
    for b_size in b_sizes:
        B = torch.arange(prod(b_size)).reshape(b_size)
        flag = False
        try:
            test = expand_as(A, B)
        except Exception as e:
            try:
                A.expand_as(B)
                print(A, B, sep='\n')
                print(f"Your function throws exception when it's not needed. Exception:{e}")
                error_counter += 1
                break
            except:
                flag = True
        if not flag:
            try:
                expected = A.expand_as(B)
                if not torch.equal(test, expected):
                    print(A, B, test, expected, sep='\n')
                    print("You didn't implemented the expand_as algorithm correctly")
                    error_counter += 1
            except Exception as e:
                print(A, B, test, sep='\n')
                print(f"The real function failed in running and you didn't. Exception:{e}")
                error_counter += 1

if error_counter == 0:
    print("Done without any failures")
else:
    print(f"Done with: {error_counter} failures")